version: 2.1

orbs:
  # helm: circleci/helm@3.0.2
  aws-ecr: circleci/aws-ecr@9.0.4
    # aws-eks: circleci/aws-eks@2.2.0
  aws-cli: circleci/aws-cli@4.1.3
    # docker: circleci/docker@2.1.1
    # azure-aks: circleci/azure-aks@0.3.0
    # kubernetes: circleci/kubernetes@1.3.0
  gh-cli: circleci/github-cli@2.3.0


parameters:
  run-recipes-go:
    default: false 
    type: boolean
  run-suppliers-go:
    default: false
    type: boolean
  run-frontend:
    default: false
    type: boolean


workflows:
  
  #IF
  Sync Frontend:
    when: << pipeline.parameters.run-frontend >>
    jobs:
    - build_and_push_image:
        context: aws-dev
        repo: frontend
    - argocd-manual-sync:
        requires: 
          - build_and_push_image
        server: $ARGOCD_SERVER
        username: $ARGOCD_USERNAME
        password: $ARGOCD_PASSWORD
        app: frontend 
  #IF
  Sync Recipes:
    when: << pipeline.parameters.run-recipes-go >>
    jobs:
    - build_and_push_image:
        context: aws-dev
        repo: recipes
    # - argocd-manual-sync:
    #     requires: [build_and_push_image]
    #     server: $ARGOCD_SERVER
    #     username: $ARGOCD_USERNAME
    #     password: $ARGOCD_PASSWORD
    #     app: recipes
  #IF
  Sync Suppliers:
    when: << pipeline.parameters.run-suppliers-go >>
    jobs:
    - build_and_push_image:
        context: aws-dev
        repo: suppliers
    - argocd-manual-sync:
        requires: 
          - build_and_push_image
        server: $ARGOCD_SERVER
        username: $ARGOCD_USERNAME
        password: $ARGOCD_PASSWORD
        app: suppliers


  #ALL
  Create Release Branch:
    jobs:
    - create_branch:
        release_name: "1.0.0-release"

jobs:

  create_branch:
    machine: 
      image: ubuntu-2004:current
    parameters:
      release_name:
        type: string
    working_directory: ~/repo
    steps:
    - checkout
    # - run:
    #   name: Check if branch exists
    #   command: |
    #     if git rev-parse --verify << parameters.release_name >>; then
    #       echo "Branch << parameters.release_name >> already exists" >&2
    #       exit 1
    #     fi

    # - run:
    #   name: Create branch
    #   command: |
    #     git checkout -b << parameters.release_name >>
    #     git commit --allow-empty -m "Initial commit"
    #     git push origin << parameters.release_name >>
    
  build_and_push_image:
    machine: 
      image: ubuntu-2004:current
    working_directory: ~/repo
    parameters:
      repo:
        type: string
    steps:
    - aws-ecr/build_and_push_image:
        attach_workspace: true
        auth:
        - aws-cli/setup:
          role_arn: arn:aws:iam::975050257492:role/Cirlce-ci-push-ecr
          aws-region: ${AWS_REGION}
          # optional parameters
          role-session-name: "example-session"
          session-duration: "1800"
        account_id: ${AWS_ECR_REGISTRY_ID}
        create_repo: true
        dockerfile: Dockerfile
        # executors: base
        # extra_build_args: '--compress'
        no_output_timeout: 20m
        path: ./recipes
        build_path: ./recipes
        platform: linux/amd64
        public_registry: false
        push_image: true
        region: ${AWS_REGION}
        repo: << parameters.repo >> 
        # repo_encryption_kms_key: arn:aws:kms::123456789012:key/UUID4_OF_KMS_KEY_ID
        # repo_encryption_type: KMS
        # repo_policy_path: repo-policy.json
        repo_scan_on_push: true
        # set_repo_policy: true
        skip_when_tags_exist: false
        tag: "<< pipeline.trigger_parameters.circleci.event_time >><< pipeline.trigger_parameters.github_app.commit_sha >>"
          # Tag the image with the date and time of the build.
          # This can be done using build automation tools or scripting.
          # The tag might look like my-app:2024-05-04T1349.
         
        # tag: $(if [[ -z "<< pipeline.git.tag >>" ]]; then
        #         echo "latest";
        #         else echo "<< pipeline.trigger_parameters.circleci.event_time >><< pipeline.trigger_parameters.github_app.commit_sha >>";
        #        fi)



  argocd-manual-sync:
    docker:
    - image: cimg/base:stable
    parameters:
      server:
        description: |
          Server IP of ArgoCD
        type: string
      username:
        description: |
          Username for ArgoCD
        type: string
      password:
        description: |
          Password for ArgoCD
        type: string
      app:
        type: string
    steps:
    - run:
        name: Install ArgoCD CLI
        command: |
          URL=https://<< parameters.server >>/download/argocd-linux-amd64
          [ -w /usr/local/bin ] && SUDO="" || SUDO=sudo
          $SUDO curl --insecure -sSL -o /usr/local/bin/argocd $URL
          $SUDO chmod +x /usr/local/bin/argocd
    - run:
        name: ArgoCD CLI login
        command: argocd login << parameters.server >> --insecure --username << parameters.username >> --password << parameters.password >>
    - run:
        name: Manual sync
        command: argocd app sync << parameters.app >>
    - run:
        name: Wait for application to reach a synced and healthy state
        command: argocd app wait << parameters.app >>


    #TEsts
    # - aws-cli/setup:
    #     #profile: OIDC-USER
    #     role_arn: arn:aws:iam::123456789012:role/VALID_OIDC_ECR_ROLE
    #     context: CircleCI_OIDC_Token
    #     create_repo: true
    #     dockerfile: Dockerfile
    #     extra_build_args: '--compress'
    #     no_output_timeout: 20m
    #     path: .
    #     platform: linux/amd64
    #     profile_name: OIDC-User
    #     public_registry: false
    #     push_image: true
    #     region: ${AWS_DEFAULT_REGION}
    #     repo: "services-project-ops"
    #     repo_encryption_kms_key: arn:aws:kms::123456789012:key/UUID4_OF_KMS_KEY_ID
    #     repo_encryption_type: KMS
    #     repo_policy_path: repo-policy.json
    #     repo_scan_on_push: true
    #     set_repo_policy: true
    #     skip_when_tags_exist: false
    #     tag: "latest"
    # - aws-ecr/push-helm-chart:
    #     account-url: $AWS_ECR_ACCOUNT_URL
    #     aws-access-key-id: $AWS_ACCESS_KEY_ID
    #     aws-secret-access-key: $AWS_SECRET_ACCESS_KEY #     create-repo: false #     path: ./charts
    #     region: eu-central-1
    #     repo: "${AWS_ECR_HELM_REPO_NAME}"
    #     tag: "latest"
    #     requires:
    #     - aws-ecr-circle/build_and_push_image

    # - argocd-configure:
    #     cluster-name: $CLUSTER_NAME
    #     resource-group: $RESOURCE_GROUP

    # - argocd-manual-sync:
    #     server: $ARGOCD_SERVER
    #     username: $ARGOCD_USERNAME
    #     password: $ARGOCD_PASSWORD
    #     requires:
    #     - argocd-configure
